// build.rs
use std::{
    env,
    fs::{self, File},
    io::{Read, Write},
    path::PathBuf,
};

use kzg::kzg_proofs::KZGSettings;
use kzg_traits::eip_4844::{load_trusted_setup_rust, load_trusted_setup_string};

/// Entry point: orchestrates reading, parsing, validating, and codegen.
fn main() {
    let setup_path = choose_setup_path();

    let mut file = File::open(&setup_path).expect("Unable to open file");
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .expect("Unable to read file");

    let (g1_monomial_bytes, g1_lagrange_bytes, g2_monomial_bytes) =
        load_trusted_setup_string(&contents).expect("Failed to load trusted setup from string");

    let settings =
        load_trusted_setup_rust(&g1_monomial_bytes, &g1_lagrange_bytes, &g2_monomial_bytes)
            .expect("Failed to load trusted setup into KZGSettings");

    let out_file = open_generated_file("trusted_setup_gen.rs");
    write_generated_code(out_file, &settings);

    // Make cargo re-run if either the file or the override env var changes.
    println!("cargo:rerun-if-changed={}", setup_path.display());
    println!("cargo:rerun-if-env-changed=KZG_TRUSTED_SETUP");

    // Helpful message during build (shows which file was used).
    println!(
        "cargo:warning=Using trusted setup: {}",
        setup_path.display()
    );
}

/* --------------------------- helpers: inputs --------------------------- */

/// Decide which trusted setup file to use:
/// - If KZG_TRUSTED_SETUP is set → use it
/// - Otherwise → <crate root>/kzg_settings/trusted_setup.txt
fn choose_setup_path() -> PathBuf {
    if let Ok(p) = env::var("KZG_TRUSTED_SETUP") {
        return PathBuf::from(p);
    }
    let crate_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    crate_root.join("kzg_settings").join("trusted_setup.txt")
}

/* ---------------------------- helpers: output ---------------------------- */

/// Open (create) the generated Rust file under OUT_DIR.
fn open_generated_file(filename: &str) -> fs::File {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set by cargo"));
    let dst = out_dir.join(filename);
    fs::File::create(&dst).unwrap_or_else(|e| panic!("failed to create {}: {e}", dst.display()))
}

/// Emit the generated Rust module with the three arrays and a helper function.
fn write_generated_code(mut out: fs::File, settings: &KZGSettings) {
    let bytes = bincode::serialize(settings).expect("failed to serialize KZGSettings");

    // Header
    writeln!(out, "/* auto-generated by build.rs — do not edit */").unwrap();

    // Arrays (embedded bytes)
    writeln!(
        out,
        "pub static KZG_SETTINGS_BYTES: &[u8; {}] = &{:?};",
        bytes.len(),
        bytes
    )
    .unwrap();

    // Helper to rebuild settings at runtime (cheap; no file I/O)
    writeln!(
        out,
        r#"
#[allow(dead_code)]
pub fn prebuilt_settings() -> kzg::kzg_proofs::KZGSettings {{
        bincode::deserialize(KZG_SETTINGS_BYTES)
            .expect("failed to deserialize KZGSettings from prebuilt bytes")
}}
"#
    )
    .unwrap();
}
