// build.rs
use std::{
    env,
    fs::{self, File},
    io::{Read, Write},
    path::PathBuf,
};

use kzg::kzg_proofs::KZGSettings;
use kzg_traits::eip_4844::{load_trusted_setup_rust, load_trusted_setup_string};

/// Entry point: orchestrates reading, parsing, validating, and codegen.
fn main() {
    let setup_path = choose_setup_path();

    let mut file = File::open(&setup_path).expect("Unable to open file");
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .expect("Unable to read file");

    let (g1_monomial_bytes, g1_lagrange_bytes, g2_monomial_bytes) =
        load_trusted_setup_string(&contents).expect("Failed to load trusted setup from string");

    let settings =
        load_trusted_setup_rust(&g1_monomial_bytes, &g1_lagrange_bytes, &g2_monomial_bytes)
            .expect("Failed to load trusted setup into KZGSettings");

    let out_file = open_generated_file("trusted_setup_gen.rs");
    write_generated_code(out_file, &settings);

    // Make cargo re-run if either the file or the override env var changes.
    println!("cargo:rerun-if-changed={}", setup_path.display());
    println!("cargo:rerun-if-env-changed=KZG_TRUSTED_SETUP");

    // Helpful message during build (shows which file was used).
    println!(
        "cargo:warning=Using trusted setup: {}",
        setup_path.display()
    );
}

/* --------------------------- helpers: inputs --------------------------- */

/// Decide which trusted setup file to use:
/// - If KZG_TRUSTED_SETUP is set → use it
/// - Otherwise → <crate root>/kzg_settings/trusted_setup.txt
fn choose_setup_path() -> PathBuf {
    if let Ok(p) = env::var("KZG_TRUSTED_SETUP") {
        return PathBuf::from(p);
    }
    let crate_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    crate_root.join("kzg_settings").join("trusted_setup.txt")
}

/* ---------------------------- helpers: output ---------------------------- */

/// Open (create) the generated Rust file under OUT_DIR.
fn open_generated_file(filename: &str) -> fs::File {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set by cargo"));
    let dst = out_dir.join(filename);
    fs::File::create(&dst).unwrap_or_else(|e| panic!("failed to create {}: {e}", dst.display()))
}

/// Emit the generated Rust module with the three arrays and a helper function.
fn write_generated_code(mut out: fs::File, settings: &KZGSettings) {
    // Serialize with rkyv to get an AlignedVec
    let aligned_bytes = rkyv::to_bytes::<rkyv::rancor::Error>(settings)
        .expect("failed to rkyv-serialize KZGSettings");

    // Verify the serialization works by testing deserialization
    let _test_settings = rkyv::from_bytes::<KZGSettings, rkyv::rancor::Error>(&aligned_bytes)
        .expect("failed to verify rkyv serialization");

    // Get the raw bytes from AlignedVec
    let bytes = aligned_bytes.as_ref();
    
    // Use 16-byte alignment - this is optimal for:
    // - rkyv deserializer requirements (needs 8+ bytes)
    // - SIMD operations that KZG proofs might use  
    // - Cache line alignment on most architectures
    let alignment = 16;

    // Header
    writeln!(out, "/* auto-generated by build.rs — do not edit */").unwrap();

    // Use the alignment value
    writeln!(out, "#[repr(align({}))]", alignment).unwrap();

    writeln!(out, "pub struct AlignedKzgBytes([u8; {}]);", bytes.len()).unwrap();

    // Implement AsRef<[u8]> for the aligned struct
    writeln!(
        out,
        r#"
impl AsRef<[u8]> for AlignedKzgBytes {{
    fn as_ref(&self) -> &[u8] {{
        &self.0
    }}
}}
"#
    )
    .unwrap();

    writeln!(
        out,
        "pub static KZG_SETTINGS_BYTES: AlignedKzgBytes = AlignedKzgBytes({:?});",
        bytes
    )
    .unwrap();

    // Helper to rebuild settings at runtime using rkyv (zero-copy deserialization)
    writeln!(
        out,
        r#"
#[allow(dead_code)]
pub fn prebuilt_settings() -> kzg::kzg_proofs::KZGSettings {{
        rkyv::from_bytes::<kzg::kzg_proofs::KZGSettings, rkyv::rancor::Error>(&KZG_SETTINGS_BYTES.0)
            .expect("failed to deserialize KZGSettings from prebuilt rkyv bytes")
}}
"#
    )
    .unwrap();
}
